[
  {
    "index": 10,
    "title": "PWM FSP code not working in ARDUINO UNO R4 WIFI",
    "link": "https://stackoverflow.com/questions/79776507/pwm-fsp-code-not-working-in-arduino-uno-r4-wifi",
    "votes": "0",
    "answers": "1",
    "views": "32",
    "tags": [
      "c",
      "arduino",
      "arduino-uno",
      "arduino-ide",
      "arduino-esp32"
    ],
    "author": "Victor Prosper",
    "excerpt": "I decided to program a PWM using an ARDUINO UNO R4 WIFI. I tried to configure the RENESAS RA4M1 microcontroller with the FSP libraries through the Arduino IDE. What I want to do is generate a PWM and ...",
    "timestamp": "2 hours ago",
    "scraped_at": "2025-09-27T01:48:43.257068",
    "question_content": "I decided to program a PWM using an ARDUINO UNO R4 WIFI. I tried to configure the RENESAS RA4M1 microcontroller with the FSP libraries through the Arduino IDE. What I want to do is generate a PWM and commute a LED connected to the pin 107 of the RENESAS (ARDUINO D5~), but the code doesn't work. Here is my code:\n#include \"common_data.h\"\n#include \"hal_data.h\"\n#include \"vector_data.h\"\n\nvoid setup() {\n\n  clock_cfg();\n  gpio_cfg();\n  pwm_cfg();\n\n}\n\nvoid loop() {\n\n}\n\n  // Clock configuration function (user defined)\n\nvoid clock_cfg() {\n\n  static cgc_instance_ctrl_t cgc_instance_ctrl;\n  static cgc_cfg_t cgc_cfg;\n  static cgc_clocks_cfg_t cgc_clocks_cfg;\n  static cgc_divider_cfg_t cgc_divider_cfg;\n\n  cgc_divider_cfg.sckdivcr_b.pclkb_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclkd_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.iclk_div  = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclka_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclkc_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.fclk_div  = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.bclk_div  = CGC_SYS_CLOCK_DIV_1;\n\n  cgc_clocks_cfg.system_clock = CGC_CLOCK_HOCO;\n  cgc_clocks_cfg.divider_cfg = cgc_divider_cfg;\n  cgc_clocks_cfg.loco_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.moco_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.hoco_state = CGC_CLOCK_CHANGE_START;\n  cgc_clocks_cfg.mainosc_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.pll_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.pll2_state = CGC_CLOCK_CHANGE_STOP;\n\n  R_CGC_Open(&cgc_instance_ctrl, &cgc_cfg);\n  R_CGC_ClocksCfg(&cgc_instance_ctrl, &cgc_clocks_cfg);\n}\n\n  // PWM configuration function (user defined)\n\nvoid pwm_cfg() {\n\n  static gpt_instance_ctrl_t gpt_instance_ctrl;\n  static timer_cfg_t gpt_cfg;\n  static gpt_extended_cfg_t gpt_extended_cfg;\n\n  static uint32_t period = 48000000;\n  static uint32_t duty = 24000000;\n  static uint8_t channel = 0;\n\n  gpt_extended_cfg.gtioca.output_enabled = true;\n  gpt_extended_cfg.gtioca.stop_level = GPT_PIN_LEVEL_LOW;\n  gpt_extended_cfg.gtiocb.output_enabled = false;\n  gpt_extended_cfg.gtiocb.stop_level = GPT_PIN_LEVEL_LOW;\n  gpt_extended_cfg.start_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.stop_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.clear_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_a_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_b_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.count_up_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.count_down_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_filter_gtioca = GPT_CAPTURE_FILTER_NONE;\n  gpt_extended_cfg.capture_filter_gtiocb = GPT_CAPTURE_FILTER_NONE;\n\n  gpt_cfg.mode = TIMER_MODE_PWM;\n  gpt_cfg.source_div = TIMER_SOURCE_DIV_1;\n  gpt_cfg.period_counts = period;\n  gpt_cfg.duty_cycle_counts = duty;\n  gpt_cfg.channel = channel;\n  gpt_cfg.p_callback = NULL;\n  gpt_cfg.p_context = NULL;\n  gpt_cfg.p_extend = &gpt_extended_cfg;\n\n  R_GPT_Open(&gpt_instance_ctrl, &gpt_cfg);\n  R_GPT_Start(&gpt_instance_ctrl);\n}\n\nvoid gpio_cfg() {\n\n  static ioport_instance_ctrl_t ioport_instance_ctrl;\n  static ioport_cfg_t ioport_cfg;\n\n  R_IOPORT_Open(&ioport_instance_ctrl, &ioport_cfg);\n  R_IOPORT_PinCfg(&ioport_instance_ctrl, BSP_IO_PORT_01_PIN_07, IOPORT_CFG_PERIPHERAL_PIN | IOPORT_PERIPHERAL_GPT0);\n}\nI have checked that the clocks are being configured since the \"delay()\" prebuild function is being affected when commuting the LED when I change the system clock divider. Also the GPIO can be configured if activated manually by setting the pin in output direction:\nR_IOPORT_PinCfg(&ioport_instance_ctrl, BSP_IO_PORT_01_PIN_07, IOPORT_CFG_PORT_DIRECTION_OUTPUT);\nAnd writting to it with the function:\nR_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_07, BSP_IO_LEVEL_HIGH);\nMysteriously for me, the pin is not outputting the PWM I want to commute the LED as described in the code above. Anyone can tell me what I am doing wrong please?",
    "question_code": [
      "#include \"common_data.h\"\n#include \"hal_data.h\"\n#include \"vector_data.h\"\n\nvoid setup() {\n\n  clock_cfg();\n  gpio_cfg();\n  pwm_cfg();\n\n}\n\nvoid loop() {\n\n}\n\n  // Clock configuration function (user defined)\n\nvoid clock_cfg() {\n\n  static cgc_instance_ctrl_t cgc_instance_ctrl;\n  static cgc_cfg_t cgc_cfg;\n  static cgc_clocks_cfg_t cgc_clocks_cfg;\n  static cgc_divider_cfg_t cgc_divider_cfg;\n\n  cgc_divider_cfg.sckdivcr_b.pclkb_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclkd_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.iclk_div  = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclka_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.pclkc_div = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.fclk_div  = CGC_SYS_CLOCK_DIV_1;\n  cgc_divider_cfg.sckdivcr_b.bclk_div  = CGC_SYS_CLOCK_DIV_1;\n\n  cgc_clocks_cfg.system_clock = CGC_CLOCK_HOCO;\n  cgc_clocks_cfg.divider_cfg = cgc_divider_cfg;\n  cgc_clocks_cfg.loco_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.moco_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.hoco_state = CGC_CLOCK_CHANGE_START;\n  cgc_clocks_cfg.mainosc_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.pll_state = CGC_CLOCK_CHANGE_STOP;\n  cgc_clocks_cfg.pll2_state = CGC_CLOCK_CHANGE_STOP;\n\n  R_CGC_Open(&cgc_instance_ctrl, &cgc_cfg);\n  R_CGC_ClocksCfg(&cgc_instance_ctrl, &cgc_clocks_cfg);\n}\n\n  // PWM configuration function (user defined)\n\nvoid pwm_cfg() {\n\n  static gpt_instance_ctrl_t gpt_instance_ctrl;\n  static timer_cfg_t gpt_cfg;\n  static gpt_extended_cfg_t gpt_extended_cfg;\n\n  static uint32_t period = 48000000;\n  static uint32_t duty = 24000000;\n  static uint8_t channel = 0;\n\n  gpt_extended_cfg.gtioca.output_enabled = true;\n  gpt_extended_cfg.gtioca.stop_level = GPT_PIN_LEVEL_LOW;\n  gpt_extended_cfg.gtiocb.output_enabled = false;\n  gpt_extended_cfg.gtiocb.stop_level = GPT_PIN_LEVEL_LOW;\n  gpt_extended_cfg.start_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.stop_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.clear_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_a_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_b_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.count_up_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.count_down_source = GPT_SOURCE_NONE;\n  gpt_extended_cfg.capture_filter_gtioca = GPT_CAPTURE_FILTER_NONE;\n  gpt_extended_cfg.capture_filter_gtiocb = GPT_CAPTURE_FILTER_NONE;\n\n  gpt_cfg.mode = TIMER_MODE_PWM;\n  gpt_cfg.source_div = TIMER_SOURCE_DIV_1;\n  gpt_cfg.period_counts = period;\n  gpt_cfg.duty_cycle_counts = duty;\n  gpt_cfg.channel = channel;\n  gpt_cfg.p_callback = NULL;\n  gpt_cfg.p_context = NULL;\n  gpt_cfg.p_extend = &gpt_extended_cfg;\n\n  R_GPT_Open(&gpt_instance_ctrl, &gpt_cfg);\n  R_GPT_Start(&gpt_instance_ctrl);\n}\n\nvoid gpio_cfg() {\n\n  static ioport_instance_ctrl_t ioport_instance_ctrl;\n  static ioport_cfg_t ioport_cfg;\n\n  R_IOPORT_Open(&ioport_instance_ctrl, &ioport_cfg);\n  R_IOPORT_PinCfg(&ioport_instance_ctrl, BSP_IO_PORT_01_PIN_07, IOPORT_CFG_PERIPHERAL_PIN | IOPORT_PERIPHERAL_GPT0);\n}",
      "R_IOPORT_PinCfg(&ioport_instance_ctrl, BSP_IO_PORT_01_PIN_07, IOPORT_CFG_PORT_DIRECTION_OUTPUT);",
      "R_IOPORT_PinWrite(&g_ioport_ctrl, BSP_IO_PORT_01_PIN_07, BSP_IO_LEVEL_HIGH);"
    ],
    "top_answer_content": "",
    "top_answer_code": [],
    "top_answer_votes": "0",
    "top_answer_accepted": false
  }
]